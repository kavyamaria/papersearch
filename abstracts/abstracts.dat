The C/C++11 concurrency model balances two goals: it is relaxed enough to be efficiently implementable and (leaving aside the ``thin-air'' problem) it is strong enough to give useful guarantees to programmers. It is mathematically precise and has been used in verification research and compiler testing. However, the model is expressed ...
In this work, we present transaction polymorphism, a synchronization technique that consists of providing more control to the programmer than traditional (i.e., monomorphic) transactions to achieve comparable performance to generic lock-based and lock-free solutions. We prove the following results: (i) Lock-based synchronization enables strictly higher concurrency than monormophic transactions. (ii) ...
In this paper, we present an approach to extending C++ with the capability of describing concurrent computation. The concurrent object-oriented model we adopt consists of a group of concurrent objects which may have bodies. When a concurrent object is created, its body begins to run. Inter-object communication uses the synchronous ...
Concurrency bugs are difficult to debug because of nondeterministic behaviors of concurrent programs. Existing fault-localization techniques for non-deadlock concurrency bugs do not provide the comprehensive information to identify and understand the bugs. Existing automatic fault-fix techniques for concurrency bugs do not provide confidence that the fault has been fixed. To ...
This workshop explores the impact and opportunities of parallel computing on application programmers.
We present a new technique to find real deadlocks in concurrent programs that use locks. For 4.5 million lines of Java, our technique found almost twice as many real deadlocks as four previous techniques combined. Among those, 33 deadlocks happened after more than one million computation steps, including 27 new ...
Concurrency control poses significant challenges when composing computations over multiple data-structures (objects) with different concurrency-control implementations. We formalize the usually desired requirements (serializability, abort-safety, deadlock-safety, and opacity) as well as stronger versions of these properties that enable composition. We show how to compose protocols satisfying these properties so that the ...
To reduce the complexity of debugging multithreaded programs, researchers have developed many techniques that automatically detect bugs that arise from shared memory errors. These techniques can identify a wide range of bugs, but it can be challenging for a programmer to reproduce a specific bug that he or she is ...
Constructing correct concurrent garbage collection algorithms is notoriously hard. Numerous such algorithms have been proposed, implemented, and deployed - and yet the relationship among them in terms of speed and precision is poorly understood, and the validation of one algorithm does not carry over to others.As programs with low latency ...
Concurrent garbage collectors are notoriously hard to design, implement, and verify. We present a framework for the automatic exploration of a space of concurrent mark-and-sweep collectors. In our framework, the designer specifies a set of "building blocks" from which algorithms can be constructed. These blocks reflect the designer's insights about ...
Several concurrency control policies for distributed systems have been proposed both by theorists and practitioners. In this paper we present an abstract framework for concurrency control policies for the serial model. This framework supports a wide range of policies and permits the integration of different policies within the same application. ...
Many disruptive changes are happening in the arena of parallel computing, including the use of multiple compute element types (CPUs and GPUs), memory and interconnect types, as well as multiple concurrency models. In the face of these changes, cybersoftware development and debugging will become increasingly hard, requiring principled (formal) debugging ...
NA
NA
NA
NA
NA
NA
NA
NA
